#!/bin/bash

# ==============================================================================
# Battery Charge Limiter & Monitor Script
# ==============================================================================
# Description: Limits battery charging thresholds, monitors battery health,
#              power draw, cycle count, and other diagnostics. Provides
#              persistence across reboots using systemd.
# Author:      AI Assistant (Gemini)
# Version:     1.1
# Requires:    bash, coreutils, grep, systemd, root privileges
# ==============================================================================

# --- Configuration ---
CONFIG_FILE="/etc/battery_limiter.conf"
SERVICE_NAME="battery-limiter.service"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}"
SCRIPT_PATH="$(realpath "$0")" # Get the full path to this script

# --- Globals ---
BATTERY_PATH=""
CHARGE_CONTROL_END_THRESHOLD_FILE=""
CHARGE_CONTROL_START_THRESHOLD_FILE="" # Less common, may not exist
HAS_THRESHOLD_CONTROL=false
CURRENT_STOP_THRESHOLD=""
CURRENT_START_THRESHOLD="" # May remain empty if not supported
LIMITER_ENABLED="false" # Loaded from config

# --- Helper Functions ---

# Function to print error messages and exit
error_exit() {
    echo "ERROR: $1" >&2
    exit 1
}

# Function to print warning messages
warning() {
    echo "WARNING: $1" >&2
}

# Check for root privileges
check_root() {
    if [[ "$EUID" -ne 0 ]]; then
        error_exit "This script must be run as root."
    fi
}

# Find the primary battery path
find_battery() {
    local bat_path
    for bat_path in /sys/class/power_supply/BAT*; do
        if [[ -d "$bat_path" && -f "$bat_path/present" && $(< "$bat_path/present") -eq 1 ]]; then
            BATTERY_PATH="$bat_path"
            echo "Detected battery: ${BATTERY_PATH##*/}"
            return 0
        fi
    done
    error_exit "No battery detected in /sys/class/power_supply/BAT*."
}

# Find charge threshold control files (Hardware Dependent!)
find_threshold_controls() {
    if [[ -z "$BATTERY_PATH" ]]; then return 1; fi

    local end_threshold_path="${BATTERY_PATH}/charge_control_end_threshold"
    local start_threshold_path="${BATTERY_PATH}/charge_control_start_threshold"

    if [[ -w "$end_threshold_path" ]]; then
        CHARGE_CONTROL_END_THRESHOLD_FILE="$end_threshold_path"
        echo "Found stop threshold control: $CHARGE_CONTROL_END_THRESHOLD_FILE"
        HAS_THRESHOLD_CONTROL=true

        # Check for the less common start threshold
        if [[ -w "$start_threshold_path" ]]; then
             CHARGE_CONTROL_START_THRESHOLD_FILE="$start_threshold_path"
             echo "Found start threshold control: $CHARGE_CONTROL_START_THRESHOLD_FILE"
        else
            warning "Start threshold control file not found or not writable. Only stop threshold can be managed."
        fi
    else
        warning "Battery charge threshold control file ('charge_control_end_threshold') not found or not writable at $end_threshold_path."
        warning "This likely means your hardware/kernel does not support setting charge limits via this standard method."
        warning "The charge limiting features of this script will NOT work."
        HAS_THRESHOLD_CONTROL=false
    fi
}

# Read a value from a sysfs file safely
read_sysfs() {
    local file_path="$1"
    local default_value="${2:-N/A}"
    if [[ -f "$file_path" ]]; then
        cat "$file_path" 2>/dev/null || echo "$default_value"
    else
        echo "$default_value"
    fi
}

# Load configuration from file
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        echo "Configuration loaded from $CONFIG_FILE."
        # Ensure boolean values are correctly interpreted
        [[ "$LIMITER_ENABLED" == "true" ]] && LIMITER_ENABLED="true" || LIMITER_ENABLED="false"
    else
        echo "No configuration file found. Using defaults."
        # Set defaults if no config file
        CURRENT_STOP_THRESHOLD=100
        CURRENT_START_THRESHOLD="" # Or perhaps a default like 0 or 90 if start is supported
        LIMITER_ENABLED="false"
    fi

    # Read actual hardware values if controls exist
    if [[ "$HAS_THRESHOLD_CONTROL" == "true" ]]; then
        local hw_stop hw_start
        hw_stop=$(read_sysfs "$CHARGE_CONTROL_END_THRESHOLD_FILE" "100")
         echo "Current hardware stop threshold: $hw_stop%"

        if [[ -n "$CHARGE_CONTROL_START_THRESHOLD_FILE" ]]; then
             hw_start=$(read_sysfs "$CHARGE_CONTROL_START_THRESHOLD_FILE" "N/A")
             echo "Current hardware start threshold: $hw_start%"
        fi
    fi
}

# Save configuration to file
save_config() {
    echo "# Battery Limiter Configuration" > "$CONFIG_FILE"
    echo "# Automatically generated by script" >> "$CONFIG_FILE"
    echo "CURRENT_STOP_THRESHOLD=${CURRENT_STOP_THRESHOLD:-100}" >> "$CONFIG_FILE"
    # Only save start threshold if it's supported and has a value
    if [[ -n "$CHARGE_CONTROL_START_THRESHOLD_FILE" && -n "$CURRENT_START_THRESHOLD" ]]; then
        echo "CURRENT_START_THRESHOLD=${CURRENT_START_THRESHOLD}" >> "$CONFIG_FILE"
    fi
    echo "LIMITER_ENABLED=${LIMITER_ENABLED:-false}" >> "$CONFIG_FILE"
    echo "Configuration saved to $CONFIG_FILE."
}

# Apply thresholds to hardware
apply_thresholds() {
    local stop_val="$1"
    local start_val="$2"

    if [[ "$HAS_THRESHOLD_CONTROL" != "true" ]]; then
        warning "Cannot apply thresholds: Hardware control not available."
        return 1
    fi

    # Apply Stop Threshold
    if [[ -n "$stop_val" ]]; then
        echo "Setting stop threshold to $stop_val%..."
        echo "$stop_val" > "$CHARGE_CONTROL_END_THRESHOLD_FILE"
        if [[ $? -ne 0 ]]; then
            warning "Failed to set stop threshold."
        else
            echo "Stop threshold set."
        fi
    fi

    # Apply Start Threshold (only if supported and value provided)
    if [[ -n "$CHARGE_CONTROL_START_THRESHOLD_FILE" && -n "$start_val" ]]; then
        echo "Setting start threshold to $start_val%..."
        echo "$start_val" > "$CHARGE_CONTROL_START_THRESHOLD_FILE"
        if [[ $? -ne 0 ]]; then
            warning "Failed to set start threshold."
        else
             echo "Start threshold set."
        fi
    elif [[ -n "$start_val" ]]; then
         warning "Start threshold control not available, cannot set start value."
    fi
}

# Create the systemd service file
create_systemd_service() {
    echo "[Unit]
Description=Apply Battery Charge Thresholds on Boot/Resume
After=multi-user.target suspend.target hibernate.target hybrid-sleep.target suspend-then-hibernate.target
StopWhenUnneeded=yes

[Service]
Type=oneshot
RemainAfterExit=no
# Ensure script path is correctly quoted if it contains spaces
ExecStart=\"${SCRIPT_PATH}\" --apply-boot

[Install]
WantedBy=multi-user.target suspend.target hibernate.target hybrid-sleep.target suspend-then-hibernate.target" > "$SERVICE_FILE"

    echo "Systemd service file created at $SERVICE_FILE"
    systemctl daemon-reload
}

# Enable and start the systemd service
install_and_enable_service() {
    if [[ ! -f "$SERVICE_FILE" ]]; then
        create_systemd_service
    fi
    echo "Enabling and starting systemd service: $SERVICE_NAME"
    systemctl enable "$SERVICE_NAME"
    # Don't start 'oneshot' immediately, it runs on boot/resume or via --apply-boot
    # systemctl start "$SERVICE_NAME" # Not needed for oneshot unless testing
    if [[ $? -ne 0 ]]; then
        warning "Failed to enable systemd service."
    else
        echo "Systemd service enabled."
    fi
}

# Disable and remove the systemd service
remove_service() {
    if systemctl is-enabled --quiet "$SERVICE_NAME"; then
        echo "Disabling systemd service: $SERVICE_NAME"
        systemctl disable "$SERVICE_NAME"
    fi
     if systemctl is-active --quiet "$SERVICE_NAME"; then
        echo "Stopping systemd service: $SERVICE_NAME"
        systemctl stop "$SERVICE_NAME"
    fi
    if [[ -f "$SERVICE_FILE" ]]; then
        echo "Removing systemd service file: $SERVICE_FILE"
        rm -f "$SERVICE_FILE"
        systemctl daemon-reload
    fi
    echo "Systemd service removed."
}

# Function called by systemd service or --apply-boot argument
apply_boot_settings() {
    echo "Applying settings triggered by systemd or --apply-boot..."
    find_battery # Ensure path is set
    if [[ $? -ne 0 ]]; then exit 1; fi # Exit if no battery
    find_threshold_controls # Check controls availability
    load_config # Load saved settings

    if [[ "$LIMITER_ENABLED" == "true" && "$HAS_THRESHOLD_CONTROL" == "true" ]]; then
        echo "Limiter is enabled in config, applying thresholds..."
        apply_thresholds "$CURRENT_STOP_THRESHOLD" "$CURRENT_START_THRESHOLD"
    elif [[ "$LIMITER_ENABLED" == "false" && "$HAS_THRESHOLD_CONTROL" == "true" ]]; then
        echo "Limiter is disabled in config, ensuring thresholds are at default (100%)..."
        apply_thresholds 100 "" # Set stop to 100, start to empty/default
    else
        echo "Limiter disabled or hardware control not available. No thresholds applied on boot."
    fi
    echo "Boot/resume settings applied."
    # No exit here if called manually, but systemd service will exit after exec.
}


# --- Feature Functions ---

prompt_set_thresholds() {
    if [[ "$HAS_THRESHOLD_CONTROL" != "true" ]]; then
        echo "Charge limiting is not supported by your hardware/kernel via this script."
        read -p "Press Enter to continue..."
        return
    fi

    local stop_threshold start_threshold
    local current_stop current_start

    # Read current hardware values for better context
    current_stop=$(read_sysfs "$CHARGE_CONTROL_END_THRESHOLD_FILE" "N/A")
    if [[ -n "$CHARGE_CONTROL_START_THRESHOLD_FILE" ]]; then
         current_start=$(read_sysfs "$CHARGE_CONTROL_START_THRESHOLD_FILE" "N/A")
    else
         current_start="N/A (Not Supported)"
    fi

    echo "Current Hardware Settings: Stop at $current_stop%, Start at $current_start%"
    echo "Configured Settings:      Stop at ${CURRENT_STOP_THRESHOLD:-N/A}%, Start at ${CURRENT_START_THRESHOLD:-N/A}%"
    echo "Limiter Status: $( [[ "$LIMITER_ENABLED" == "true" ]] && echo "Enabled" || echo "Disabled" )"
    echo "---"

    while true; do
        read -p "Enter STOP charging percentage (e.g., 80, current: ${CURRENT_STOP_THRESHOLD:-N/A}): " stop_threshold
        # Use default if empty
        stop_threshold=${stop_threshold:-$CURRENT_STOP_THRESHOLD}
        if [[ "$stop_threshold" =~ ^[0-9]+$ && "$stop_threshold" -ge 10 && "$stop_threshold" -le 100 ]]; then
            break
        else
            echo "Invalid input. Please enter a number between 10 and 100."
        fi
    done

    if [[ -n "$CHARGE_CONTROL_START_THRESHOLD_FILE" ]]; then
        while true; do
            read -p "Enter RESUME charging percentage (e.g., 50, current: ${CURRENT_START_THRESHOLD:-N/A}): " start_threshold
            # Use default if empty
            start_threshold=${start_threshold:-$CURRENT_START_THRESHOLD}
            if [[ "$start_threshold" =~ ^[0-9]+$ && "$start_threshold" -ge 5 && "$start_threshold" -lt "$stop_threshold" ]]; then
                break
            else
                 echo "Invalid input. Please enter a number between 5 and $((stop_threshold - 1))."
                 echo "The resume threshold must be lower than the stop threshold."
            fi
        done
    else
        start_threshold="" # Cannot set start threshold
        echo "Start threshold control not supported, only setting stop threshold."
    fi

    # Apply immediately
    apply_thresholds "$stop_threshold" "$start_threshold"

    # Update global config vars and save
    CURRENT_STOP_THRESHOLD="$stop_threshold"
    CURRENT_START_THRESHOLD="$start_threshold" # Will be empty if not supported
    LIMITER_ENABLED="true" # Assume enabling when setting thresholds
    save_config

    # Ensure service is installed and enabled for persistence
    install_and_enable_service

    echo "Thresholds set and limiter enabled. Persistence configured."
    read -p "Press Enter to continue..."
}

disable_limiter() {
    if [[ "$HAS_THRESHOLD_CONTROL" != "true" ]]; then
        echo "Charge limiting was likely never active as hardware control is not available."
        # Still allow disabling the service if it exists
    else
        echo "Resetting charge thresholds to default (100%)..."
        apply_thresholds 100 "" # Set stop to 100, clear start
    fi

    LIMITER_ENABLED="false"
    CURRENT_STOP_THRESHOLD=100 # Update config variable
    CURRENT_START_THRESHOLD=""  # Update config variable
    save_config # Save the disabled state

    # Remove or disable the service
    remove_service # This disables and removes the service file

    echo "Charge limiter disabled, thresholds reset to defaults, and persistence service removed."
    read -p "Press Enter to continue..."
}


monitor_power_draw() {
    echo "Starting real-time power monitoring (Press Ctrl+C to stop)..."
    trap 'echo ""; echo "Stopping power monitoring."; return' SIGINT # Handle Ctrl+C gracefully within function

    local voltage_uv current_ua power_w status capacity
    local voltage_v current_a

    while true; do
        status=$(read_sysfs "${BATTERY_PATH}/status" "N/A")
        capacity=$(read_sysfs "${BATTERY_PATH}/capacity" "N/A")%
        voltage_uv=$(read_sysfs "${BATTERY_PATH}/voltage_now" "0")
        current_ua=$(read_sysfs "${BATTERY_PATH}/current_now" "0")
        # Some systems provide power_now directly (in microwatts)
        power_uw=$(read_sysfs "${BATTERY_PATH}/power_now" "")

        if [[ -n "$power_uw" && "$power_uw" != "N/A" ]]; then
             # Use direct power reading if available
             power_w=$(awk "BEGIN {printf \"%.2f\", $power_uw / 1000000}")
        elif [[ "$voltage_uv" != "N/A" && "$current_ua" != "N/A" && "$voltage_uv" -gt 0 && "$current_ua" -gt 0 ]]; then
            # Calculate from voltage and current
            voltage_v=$(awk "BEGIN {printf \"%.2f\", $voltage_uv / 1000000}")
            current_a=$(awk "BEGIN {printf \"%.2f\", $current_ua / 1000000}")
            power_w=$(awk "BEGIN {printf \"%.2f\", $voltage_v * $current_a}")
        else
            power_w="N/A"
        fi

        # Determine if charging or discharging based on status
        local direction=""
        case "$status" in
            "Charging") direction="Charge Rate" ;;
            "Discharging") direction="Discharge Rate" ;;
            "Full") direction="Power Draw (Full)" ;;
             "Not charging") direction="Power Draw (Not charging)" ;; # Some systems report this
            *) direction="Power Draw" ;;
        esac

        # \r moves cursor to beginning of line, -n prevents newline
        # Pad with spaces to clear previous longer lines
        printf "\rStatus: %-12s | Capacity: %s | %-20s: %s W   " "$status" "$capacity" "$direction" "$power_w"

        sleep 1
    done

    # Clean up trap and potentially clear the line
    trap - SIGINT
    echo ""
}

show_battery_health() {
    local full full_design health temp voltage current status capacity cycle_count runtime technology model manufacturer serial

    full=$(read_sysfs "${BATTERY_PATH}/charge_full" "0")
    full_design=$(read_sysfs "${BATTERY_PATH}/charge_full_design" "0")
    temp_raw=$(read_sysfs "${BATTERY_PATH}/temp" "N/A") # Often deci-Celsius
    voltage=$(read_sysfs "${BATTERY_PATH}/voltage_now" "N/A") # microVolts
    current=$(read_sysfs "${BATTERY_PATH}/current_now" "N/A") # microAmps
    status=$(read_sysfs "${BATTERY_PATH}/status" "N/A")
    capacity=$(read_sysfs "${BATTERY_PATH}/capacity" "N/A")
    cycle_count=$(read_sysfs "${BATTERY_PATH}/cycle_count" "N/A")
    technology=$(read_sysfs "${BATTERY_PATH}/technology" "N/A")
    model=$(read_sysfs "${BATTERY_PATH}/model_name" "N/A")
    manufacturer=$(read_sysfs "${BATTERY_PATH}/manufacturer" "N/A")
    serial=$(read_sysfs "${BATTERY_PATH}/serial_number" "N/A")
    # Some systems might have time_to_empty or time_to_full
    runtime=$(read_sysfs "${BATTERY_PATH}/time_to_empty" "")
    chargetime=$(read_sysfs "${BATTERY_PATH}/time_to_full" "")


    echo "--- Battery Health & Diagnostics ---"

    # Health Calculation
    if [[ "$full" != "N/A" && "$full_design" != "N/A" && "$full_design" -gt 0 ]]; then
        health=$(awk "BEGIN {printf \"%d\", ($full / $full_design) * 100}")
        echo "Health (Wear Level):     $health%"
        echo "Capacity (Current Full): $full (energy units, e.g., uAh or uWh)"
        echo "Capacity (Design Full):  $full_design (energy units)"
    else
        echo "Health (Wear Level):     N/A (charge_full or charge_full_design missing)"
    fi

    echo "Cycle Count:             $cycle_count"
    echo "---"
    echo "Current Status:          $status"
    echo "Current Capacity:        $capacity%"

     # Temperature Conversion (assuming deci-Celsius)
    if [[ "$temp_raw" != "N/A" && "$temp_raw" =~ ^-?[0-9]+$ ]]; then
        temp_c=$(awk "BEGIN {printf \"%.1f\", $temp_raw / 10}")
        echo "Temperature:             ${temp_c}°C"
    else
         echo "Temperature:             N/A"
    fi

     # Voltage Conversion (assuming microVolts)
    if [[ "$voltage" != "N/A" && "$voltage" =~ ^[0-9]+$ ]]; then
        voltage_v=$(awk "BEGIN {printf \"%.2f\", $voltage / 1000000}")
        echo "Voltage:                 ${voltage_v} V"
    else
        echo "Voltage:                 N/A"
    fi

     # Current Conversion (assuming microAmps)
    if [[ "$current" != "N/A" && "$current" =~ ^[0-9]+$ ]]; then
        current_a=$(awk "BEGIN {printf \"%.3f\", $current / 1000000}")
         echo "Current:                 ${current_a} A"
    else
         echo "Current:                 N/A"
    fi

     # Estimated Runtime/Chargetime (value is often in seconds)
    local time_estimate=""
    if [[ "$status" == "Discharging" && -n "$runtime" && "$runtime" != "N/A" && "$runtime" =~ ^[0-9]+$ && "$runtime" -gt 0 ]]; then
        time_estimate=$(printf '%dh %dm' $(($runtime/3600)) $(($runtime%3600/60)))
        echo "Estimated time to empty: $time_estimate"
    elif [[ "$status" == "Charging" && -n "$chargetime" && "$chargetime" != "N/A" && "$chargetime" =~ ^[0-9]+$ && "$chargetime" -gt 0 ]]; then
        time_estimate=$(printf '%dh %dm' $(($chargetime/3600)) $(($chargetime%3600/60)))
        echo "Estimated time to full:  $time_estimate"
    else
         echo "Estimated Runtime:       N/A"
    fi

    echo "---"
    echo "Technology:              $technology"
    echo "Manufacturer:            $manufacturer"
    echo "Model:                   $model"
    echo "Serial Number:           $serial"
    echo "------------------------------------"
    read -p "Press Enter to continue..."
}

show_help() {
    echo "Usage: $0 [command]"
    echo
    echo "Battery Charge Limiter & Monitor"
    echo "Manages battery charge thresholds (if hardware supported) and monitors battery status."
    echo "Run without arguments to show the interactive menu."
    echo "Requires root privileges."
    echo
    echo "Commands:"
    echo "  --help          Show this help message."
    echo "  --apply-boot    (Internal) Apply saved settings; typically run by systemd service."
    echo
    echo "Features (via interactive menu):"
    echo "  - Set Charge Thresholds: Define stop and resume charging percentages."
    echo "  - Disable Limiter: Remove limits, reset to 100%, disable persistence."
    echo "  - Monitor Power Draw: Show real-time charge/discharge rate in Watts."
    echo "  - Show Battery Health/Diagnostics: Display wear level, cycle count, temp, etc."
    echo
    echo "Dependencies: bash, coreutils, grep, systemd"
    echo
    echo "Configuration File: $CONFIG_FILE"
    echo "Systemd Service:    $SERVICE_FILE"
    echo
    echo "WARNING: Setting charge thresholds requires specific hardware and kernel support."
    echo "         If 'charge_control_end_threshold' is not found, limiting will not work."
}

# --- Main Menu ---
main_menu() {
    while true; do
        clear
        echo "========================================="
        echo " Battery Charge Limiter & Monitor"
        echo "========================================="
        echo " Battery: ${BATTERY_PATH##*/}"
        local current_stop="N/A" current_start="N/A" enabled_status="Disabled" hw_controls="No"
         if [[ "$HAS_THRESHOLD_CONTROL" == "true" ]]; then
            hw_controls="Yes"
            current_stop=$(read_sysfs "$CHARGE_CONTROL_END_THRESHOLD_FILE" "N/A")
            if [[ -n "$CHARGE_CONTROL_START_THRESHOLD_FILE" ]]; then
                current_start=$(read_sysfs "$CHARGE_CONTROL_START_THRESHOLD_FILE" "N/A")
            fi
         fi

        if [[ "$LIMITER_ENABLED" == "true" && "$HAS_THRESHOLD_CONTROL" == "true" ]]; then
            enabled_status="Enabled (Stop: ${CURRENT_STOP_THRESHOLD:-?}%, Start: ${CURRENT_START_THRESHOLD:-?%})"
        elif [[ "$LIMITER_ENABLED" == "true" && "$HAS_THRESHOLD_CONTROL" == "false" ]]; then
             enabled_status="Configured but Inactive (Hardware Unsupported)"
        else
            enabled_status="Disabled (Thresholds at default: ${current_stop:-100}%)"
        fi

        echo " Hardware Threshold Control: $hw_controls"
        echo " Limiter Status: $enabled_status"
        echo "-----------------------------------------"
        echo " Menu:"
        if [[ "$HAS_THRESHOLD_CONTROL" == "true" ]]; then
             echo "  1) Set Charge Thresholds & Enable Limiter"
             echo "  2) Disable Limiter & Reset Thresholds"
        else
            echo "  1) Set Charge Thresholds (Not Supported)"
            echo "  2) Disable Limiter (Reset if possible)"
        fi
        echo "  3) Monitor Real-time Power Draw"
        echo "  4) Show Battery Health & Diagnostics"
        echo "  5) Re-apply Saved Settings Now"
        echo "  H) Help"
        echo "  Q) Quit"
        echo "-----------------------------------------"
        read -p "Enter your choice: " choice

        case "$choice" in
            1) prompt_set_thresholds ;;
            2) disable_limiter ;;
            3) monitor_power_draw ;;
            4) show_battery_health ;;
            5) apply_boot_settings # Reuse the boot function to apply current config now
               read -p "Press Enter to continue..." ;;
            [Hh]) show_help; read -p "Press Enter to continue..." ;;
            [Qq]) echo "Exiting."; exit 0 ;;
            *) echo "Invalid choice. Please try again."; sleep 1 ;;
        esac
    done
}

# --- Main Execution ---

# Handle command-line arguments first
if [[ "$1" == "--help" ]]; then
    show_help
    exit 0
fi

# Check for root BEFORE trying the --apply-boot which might be run by systemd as root
if [[ "$1" == "--apply-boot" ]]; then
    # Usually run by systemd, should have root. Add a check anyway.
    check_root
    apply_boot_settings
    exit 0 # Exit after applying settings for the service
fi

# --- Script Start for Interactive Use ---
check_root
echo "Initializing Battery Limiter Script..."
find_battery
find_threshold_controls # Determine if limiting is possible
load_config # Load saved settings AFTER finding controls

# Enter the main menu loop
main_menu

exit 0 # Should not be reached if main_menu is exited via 'Q'
